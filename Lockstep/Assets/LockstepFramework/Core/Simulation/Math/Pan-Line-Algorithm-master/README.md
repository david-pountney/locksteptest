FractionalLineAlgorithm.Trace (startX, startY, endX, endY) will return a series of coordinates that overlap the line segment formed by the positions (startX, startY) and (endX, endY) with approximately 0(Magnitude of line) performance. I named it after my last name because that's what all the cool line algorithm creators are doing (i.e. Bresenham's Line Algorithm) but changed the class name to FractionalLineAlgorithm because using my last name all the time felt weird as fack.

I gave up on commenting while developing this algorithm. I  went all out on bad coding habits to get it done. I'm talkin' copy-pastes, 250+ line function, nested class, fuck namespaces, and more. For some reason, I decided that copy-pasting whole pages of code would be easier than making more functions. Anyways, thanks for reading my life story. There's a lot of room for optimization and tidying up the code which I plan to get to soon. For now, it's tested and working properly.

The core concept of this algorithm is similar to Bresenham's in that it increments by 1 unit on one axis and tests the increase on the other axis. Fractions make incrementing considerably more difficult, however, and a lot of pizzas had to be added in. For example, incrementing from X = .21 to X = 1.21 with a slope of 5 makes for a complex problem (coordinate patterns between those nasty numbers are hard to predict) but incrementing from 1 to 2 with a slope of 5 makes for an easy problem. Coordinate pattern between integers is very easy to solve (just a line perpendicular to the incrementing axis). To get the easy problem, the incrementing is offset to an integer number with all the calculations done seperately for the fractional piece. So instead of starting the incrementing on .21, the algorithm tries to start the incrementing on 1 and goes from there.
